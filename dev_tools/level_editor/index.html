<!doctype html>
<html>
<head>

<script src="mouse_utils.js"></script>
<script src="selection.js"></script>
<script src="edit_history.js"></script>
<script src="tile_sets.js"></script>
<script src="level_set.js"></script>
<script src="connects_editing.js"></script>

<style>

    body {
        background-color: black;
        font-family: sans-serif;
        color: white;
    }

    div.topBar {
        display: flex;
		flex-flow: row wrap;
		justify-content: space-between;
		align-items: center;
		align-content: center;
    }

    select.worldPulldown, select.levelPulldown {
        font-size: 1.2rem;
    }

    div.panelTabs {
        display: flex;
		flex-flow: row;
		justify-content: left;
		align-items: baseline;
		align-content: center;
    }

    div.panelTabs div:first-child {
        border-top-left-radius: 10px;
        border-bottom-left-radius: 10px;
    }

    div.panelTabs div:last-child {
        border-top-right-radius: 10px;
        border-bottom-right-radius: 10px;
    }

    div.panelTabs div {
        border-color: gray;
        border-style: solid;
        border-width: 2px;
        padding: 0.2em 2em 0.2em 2em;
        font-size: 0.8em;
    }

    div.panelTabs div.selected {
        background-color: rgba(200, 200, 200, 0.7);
    }

    @media screen and (-webkit-min-device-pixel-ratio:0) {
        input[type='range'] {
            overflow: hidden;
            background-color: rgba(255,255,255,0.5);
            border-radius: 0.5em;
            -webkit-appearance: none;
        }
        input[type='range']::-webkit-slider-thumb {
            width: 15px;
            -webkit-appearance: none;
            height: 15px;
            cursor: ew-resize;
            border-radius: 0.5em;
            background: #FFFFFF;
        }
    }

    input[type="range"]::-moz-range-track {
        background-color: rgba(255,255,255,0.5);
    }

    input.levelPicsOpacitySlider {
        min-width: 5em;
    }

    canvas {
        border: 2px solid gray;
	}

    canvas.levelPicsCanvas {
        height: 400px;
        aspect-ratio: 21.76; /* (10240 / 400) * (34 / 40) */
    }

    canvas.levelInteractionCanvas {
        position: absolute;
        height: 400px;
        aspect-ratio: 21.76; /* (10240 / 400) * (34 / 40) */
    }

    canvas.levelSpriteCanvas {
        position: absolute;
        height: 400px;
        aspect-ratio: 21.76; /* (10240 / 400) * (34 / 40) */
    }

    canvas.levelIdsCanvas {
        position: absolute;
        height: 400px;
        aspect-ratio: 21.76; /* (10240 / 400) * (34 / 40) */
    }

    div.levelContainer {
        position: relative;
        width: 98%;
        overflow-x: scroll;
        margin: 0 1%;
    }

    div.levelContainer:focus-within > canvas {
        border:2px solid #4848FF;
    }

    div.mapColumnIndexes {
        width: 8704px;
        display: flex;
		justify-content: stretch;
		align-items: baseline;
        padding: 0;
        margin: 0 2px;
		align-content: center;
    }
    div.mapColumnIndexes > div {
        display: inline;
        color: gray;
        width: 34px;
        font-size: 14px;
        margin: 0 0.5px;
        padding: 2px 0 2px 0;
        text-align: center;
    }
    div.mapColumnIndexes > div.odd {
        background-color: rgba(200, 200, 200, 0.2);
    }
    div.mapColumnIndexes > div.roundleft {
        border-top-left-radius: 4px;
        border-bottom-left-radius: 4px;
    }
    div.mapColumnIndexes > div.roundright {
        border-top-right-radius: 4px;
        border-bottom-right-radius: 4px;
    }

    div.bottomPanel {
        display: flex;
		flex-flow: row wrap;
		justify-content: start;
		align-items: baseline;
		align-content: start;
    }

    div.connectsEditingForm {
        display: flex;
        margin: 0.5em 0.5em;
		flex-flow: row;
		justify-content: start;
		align-items: baseline;
		align-content: center;
        padding: 0.2em;
        background-color: rgba(60, 60, 60, 0.6);
		justify-content: space-between;
        border-radius: 7px;
    }

    div.connectsEditingSubForm {
        display: flex;
		flex-flow: row wrap;
		justify-content: start;
		align-items: baseline;
		align-content: center;
    }

    div.connectsEditingSubForm > div.oneItem {
        padding: 0.2em 0.4em;
    }

    div.connectsEditingRow {
        display: flex;
		flex-flow: row;
		justify-content: start;
		align-items: baseline;
		align-content: start;
    }

    div.connectsEditingRow > div {
        font-size: 0.9em;
        padding: 0.2em 0.4em;
    }

    div.connectsView {
        display: flex;
		flex-flow: row wrap;
		justify-content: start;
		align-items: baseline;
		align-content: center;
    }

    table.connectsTable {
        margin: 0 1.1em 0 0.5em;
        border-spacing: 0;
        font-family: monospace;
        font-size: 1rem;
    }

    table.connectsTable thead tr th {
        color: rgba(80, 80, 80, 1);
        font-size: 0.9em;
        text-align: right;
        padding: 0 0 0.3em 0.3em;
    }

    table.connectsTable tbody tr:hover {
        background-color: rgba(110,110,110,0.5);
    }

    table.connectsTable tbody tr:nth-child(even) td {
        background-color: rgba(60,60,60,0.4);
    }

    table.connectsTable tbody tr td.connectCoordinates.start {
        border-radius: 6px 0 0 6px;
    }

    table.connectsTable tbody tr td.connectCoordinates.end {
        border-radius: 0 6px 6px 0;
    }

    table.connectsTable tbody tr:hover td.connectCoordinates {
        background-color: rgba(130,130,130,0.8);
        cursor: pointer;
    }

    table.connectsTable tbody tr td {
        padding: 0.1em 0.2em 0.1em 0.4em;
        text-align: right;
    }

    table.connectsTable tbody tr td:first-child {
        color: gray;
        padding-left: 0.6em;
        border-radius: 6px 0 0 6px;
        font-size: 0.9em;
    }

    table.connectsTable tbody tr td:last-child {
        padding-right: 0.6em;
        border-radius: 0 6px 6px 0;
    }

    table.connectsTable tbody tr.selected {
        background-color: rgba(0, 0, 255, 0.5);
    }

    table.connectsTable tbody tr.selected:hover td.connectCoordinates {
        background-color: rgba(80,80,255,0.8);
        cursor: pointer;
    }

    table.connectsTable tbody tr.blank td {
        color: gray;
    }

    table.connectsTable tbody tr.selected td {
        border-width: 0.1em 0 0.1em 0;
        padding: 0 0.2em 0 0.4em;
        border-color: blue;
        border-style: solid;
    }

    table.connectsTable tbody tr.selected td:first-child {
        border-left-width: 0.1em;
    }

   table.connectsTable tbody tr.selected td:last-child {
        border-right-width: 0.1em;
    }

    div.pictureBlockSelectionContainer {
        position: relative;
        margin: 0.5em 1%;
    }

    canvas.pictureBlockSelectionCanvas {
        height: 512px;
        aspect-ratio: 1.0625; /* (640 / 512) * (34 / 40) */
    }

    canvas.pictureBlockSelectionInteractionCanvas {
        height: 512px;
        position: absolute;
        aspect-ratio: 1.0625; /* (640 / 512) * (34 / 40) */
    }

    div.typeBlockSelectionContainer {
        position: relative;
        margin: 0.5em 1%;
    }

    canvas.typeBlockSelectionCanvas {
        height: 512px;
        aspect-ratio: 0.265625; /* (160 / 512) * (34 / 40) */
    }

    canvas.typeBlockSelectionInteractionCanvas {
        height: 512px;
        position: absolute;
        aspect-ratio: 0.265625; /* (160 / 512) * (34 / 40) */
    }

</style>

<script>

// Used for auto-selecting a block type when a block picture is selected
var firstBlocksetTypeEquivalents = [
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,20,20,20,0,0,0,0,0,0,0,0,0,0,
        0,0,0,20,20,20,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,2,3,1,0,0,48,48,48,
        49,49,49,49,20,20,20,20,48,48,48,48,0,0,0,0,
        48,48,48,48,0,0,0,0,56,56,56,56,20,20,20,0,
        56,56,56,56,20,0,20,0,0,0,0,0,0,0,0,0,
        48,48,48,0,0,0,0,0,48,48,48,20,0,0,0,0,
        28,29,29,29,29,29,29,26,30,31,31,31,31,31,31,27,
        46,48,47,44,44,20,20,20,46,48,47,48,48,0,0,0,
        46,48,47,45,45,0,0,0,46,48,47,44,44,20,20,20,
        46,48,47,48,48,20,20,20,46,48,47,45,45,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,17,8,0,0,0,0,0,0,17,8,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];

const tileHeight = 32;
const tileWidth = 40;

const mapColumns = 256;
const mapRows = 12;


async function startEditor() {

    document.editingMode = "map";

    document.worldNumber = 1;
    document.levelNumber = 0;
    document.blockPictureSelection = 0;
    document.blockTypeSelection = 0;
    document.selectedConnect = 0;

    document.pendingLevelChanges = null;    // LevelUndoHistoryEntry
    document.levelHistory = new LevelHistory();

    document.mapSelection = new MapSelection(mapColumns, mapRows);

    // First task: Load the tiles for the editor.

    // There is an alternate approach to this that involves using CSS to create images out of snippets of a larger image,
    // but we're rolling with the design of rendering the editor as a giant canvas rather than a grid of image elements,
    // so this approach makes more sense.

    document.blockUnderPointer = {x: 0, y: 0};
    document.blockLastMouseDown = null;

    document.optionKeyOnMouseDown = false;
    document.commandKeyOnMouseDown = false;
    document.shiftKeyOnMouseDown = false;

    document.levelMapHasFocus = false;

    var tempCanvas = document.getElementById("tempCanvas");
	var spriteCanvas = document.getElementById("levelSpriteCanvas");

    document.editorTiles = new EditorTileset(tempCanvas);
    await document.editorTiles.load("editor_tiles.png", 16, 8, tileWidth, tileHeight);

    document.connectsEditing = new ConnectsEditing(mapColumns, mapRows, spriteCanvas, document.editorTiles);

    redrawMapColumnIndexes();
    populateTypeBlockSelector();
    selectTypeBlock(0);
    changeMapPicsLayerOpacity();

    await selectWorld(1);
    selectMapPanel();
    selectPictureBlock(0);

    // Mnaually adding these to the whole document because Safari
    // ignores them in their more sensible positions.
    document.addEventListener("copy", onLevelMapCopy);
    document.addEventListener("cut", onLevelMapCut);
    document.addEventListener("paste", onLevelMapPaste);
}


// Recreate the hex-based column labels along the bottom of the map view
function redrawMapColumnIndexes() {
    const c = document.getElementById("mapColumnIndexes");

    while (c.firstChild) { c.removeChild(c.lastChild); }

    for (var i=0; i < mapColumns; i++) {
        const d = document.createElement("div");
        var classes = [];
        if (Math.floor(i / 16) % 2) {
            classes.push("odd");
            if ((i % 16) == 0) {
                classes.push("roundleft");
            } else if ((i % 16) == 15) {
                classes.push("roundright");
            }
        }
        d.className = classes.join(" ");
        const t = document.createTextNode(i.toString(16).toUpperCase());
        d.appendChild(t);
        c.appendChild(d);
    }
}


async function worldPulldownChanged() {
    const s = document.getElementById("worldPulldown");
    selectWorld(s.value);
}


async function selectWorld(newWorld) {
    document.worldNumber = newWorld;

    var tempCanvas = document.getElementById("tempCanvas");
    var secondCanvas = document.getElementById("tempBlockSetCanvas");
    var singleBlockCanvas = document.getElementById("tempBlockCanvas");

    document.pictureTiles = new WorldTileset(tempCanvas, secondCanvas, singleBlockCanvas);
    await document.pictureTiles.load(
        "/block_sets/world_" + newWorld + "-blocks.png",
        "/block_sets/world_" + newWorld + "-block_pointers.bin",
        16, 12, tileWidth, tileHeight);

    document.levelData = new LevelSet(mapColumns, mapRows);
    await document.levelData.load("/level_maps/world_" + newWorld + "-level_1_to_4.bin");

    populatePictureBlockSelector();

    selectLevel(document.levelNumber);
}


function levelPulldownChanged() {
    const s = document.getElementById("levelPulldown");
    selectLevel(s.value);
}


function forceLevelSelect(newLevel) {
    const s = document.getElementById("levelPulldown");
    s.value = newLevel;
    selectLevel(newLevel);
}


function selectLevel(newLevel) {
    document.levelNumber = newLevel;
    drawLevel();
    redrawConnectsPanel();
    redrawSpriteCanvas();
}


function selectMapPanel() {
    const mt = document.getElementById("mapEditingPanelTab");
    const ct = document.getElementById("connectsPanelTab");

    mt.className = "selected";
    ct.className = "";

    const mp = document.getElementById("mapEditingPanel");
    const cp = document.getElementById("connectsPanel");

    mp.style.display = "block";
    cp.style.display = "none";

    document.editingMode = "map";
    redrawSpriteCanvas();
}


function selectConnectsPanel() {
    const mt = document.getElementById("mapEditingPanelTab");
    const ct = document.getElementById("connectsPanelTab");

    mt.className = "";
    ct.className = "selected";

    const mp = document.getElementById("mapEditingPanel");
    const cp = document.getElementById("connectsPanel");

    mp.style.display = "none";
    cp.style.display = "block";

    document.editingMode = "connects";
    redrawSpriteCanvas();
}


function redrawConnectsPanel() {
    const connects = document.levelData.getDoorConnects(document.levelNumber);

    // Populate the edit area

    const selectedConnectData = connects[document.selectedConnect];

    const dt = document.getElementById("destinationTypePulldown");
    dt.value = selectedConnectData.destinationType;
    const ci = document.getElementById("connectIdentifierPulldown");
    ci.value = selectedConnectData.destinationId;
    const fo = document.getElementById("connectFifthOffsetPulldown");
    fo.value = selectedConnectData.destinationXFifthOffset;

    // Populate the table

    const ft = document.getElementById("connectsFirstTableBody");
    const st = document.getElementById("connectsSecondTableBody");
    const bodies = [ft, st];

    const destinationTypes = ['In', 'Other', 'Set', 'World'];

	bodies.forEach(function(tableBody, tableIndex) {
        while (tableBody.firstChild) { tableBody.removeChild(tableBody.lastChild); }
        for (var index=0; index < 16; index++) {
            const connectIndex = index + (tableIndex*16);
            const c = connects[connectIndex];
            const tr = document.createElement("tr");

            const textNodes = [
                (connectIndex+1) + ".",
                c.x.toString(16).toUpperCase(),
                c.y.toString(16).toUpperCase(),
                destinationTypes[c.destinationType],
                c.destinationId,
                c.destinationX.toString(16).toUpperCase(),
                c.destinationY.toString(16).toUpperCase(),
                c.destinationWindowX.toString(16).toUpperCase(),
                c.destinationXFifthOffset,
                c.extraData
            ];

            const cells = textNodes.map(function(v) {
                const td = document.createElement("td");
                const t = document.createTextNode(v);
                td.appendChild(t);
                tr.appendChild(td);
                return td;
            });

            // Add a specific click handler for the origin coordinates
            [cells[1], cells[2]].forEach(function (td) {
                td.addEventListener("click", function (e) { showConnectOrigin(connectIndex); });
            });
            cells[1].className = "connectCoordinates start";
            cells[2].className = "connectCoordinates end";

            // Specific click handler for the destination coordinates
            [cells[5], cells[6], cells[7]].forEach(function (td) {
                td.addEventListener("click", function (e) { showConnectDestination(connectIndex); });
            });
            cells[5].className = "connectCoordinates start";
            cells[6].className = "connectCoordinates";
            cells[7].className = "connectCoordinates end";

            tableBody.appendChild(tr);

            if ((c.x == 0) && (c.y == 11) && (c.destinationX == 0) && (c.destinationY == 0)) { tr.className = "blank"; }
            if (document.selectedConnect == connectIndex) { tr.className = "selected"; }
            tr.addEventListener("click", function (e) { selectConnectForEditing(connectIndex); });
        }
    });
}


function showConnectOrigin(index) {
    const connects = document.levelData.getDoorConnects(document.levelNumber);
    const selectedConnectData = connects[index];
    const newSelection = [{ x: selectedConnectData.x, y: (mapRows-1) - selectedConnectData.y }];
    changeRedrawAndShowSelection(newSelection, true);
    // We don't .preventDefault so the event bubbles up to the selectConnectForEditing handler.
}


function showConnectDestination(index) {
    const connects = document.levelData.getDoorConnects(document.levelNumber);
    const selectedConnectData = connects[index];
    const newSelection = [{ x: selectedConnectData.destinationX, y: (mapRows-1) - selectedConnectData.destinationY }];
    changeRedrawAndShowSelection(newSelection, true);
    // We don't .preventDefault so the event bubbles up to the selectConnectForEditing handler.
}


function changeRedrawAndShowSelection(newSelection, dontScrollIfAlreadyInView) {
    document.mapSelection.clear();
    eraseInteractionRectangle({x: 0, y: 0}, {x: mapColumns-1, y: mapRows-1});
    document.mapSelection.select(newSelection);
    drawSelectionIndicators(newSelection);
    const upperLeft = document.mapSelection.getUpperLeftCorner();
    scrollToBlock(upperLeft.x, dontScrollIfAlreadyInView);
    // The reticle may have been erased by the previous steps, so we need to redraw it.
    drawTypeTile(document.blockUnderPointer.x, document.blockUnderPointer.y, 64, true);
}


function scrollToBlock(x, dontScrollIfAlreadyInView) {
    const levelView = document.getElementById("levelContainer");
    const blockSize = levelView.scrollWidth / 256;
    const columnsVisible = Math.floor(levelView.clientWidth / blockSize);
    const currentBlockAtLeftEdge = Math.ceil(levelView.scrollLeft / blockSize);
    const maxScroll = levelView.scrollWidth - levelView.clientWidth;
    if (dontScrollIfAlreadyInView) {
        if ((x >= currentBlockAtLeftEdge) && (x < (currentBlockAtLeftEdge + columnsVisible) - 1)) {
            return;
        }
    }
    levelView.scrollLeft = Math.min(x * blockSize, maxScroll);
}


function redrawSpriteCanvas() {
    var canvas = document.getElementById("levelSpriteCanvas");
    var canvasContext = canvas.getContext("2d");
    canvasContext.clearRect(0, 0, tileWidth*mapColumns, tileHeight*mapRows);

    if (document.editingMode == "connects") {
        document.connectsEditing.drawAllGuidoConnects(
            document.levelData, document.levelNumber, document.selectedConnect);
    }
}


function selectConnectForEditing(connectIndex) {
    document.selectedConnect = connectIndex;
    redrawConnectsPanel();
    redrawSpriteCanvas();
}


function connectDestinationTypeChanged() {
    const connects = document.levelData.getDoorConnects(document.levelNumber);
    const selectedConnectData = connects[document.selectedConnect];

    const ci = document.getElementById("destinationTypePulldown");
    selectedConnectData.destinationType = parseInt(ci.value);
    document.levelData.writeDoorConnect(document.levelNumber, document.selectedConnect, selectedConnectData);
    redrawConnectsPanel();
    redrawSpriteCanvas();
}


function connectIdentifierChanged() {
    const connects = document.levelData.getDoorConnects(document.levelNumber);
    const selectedConnectData = connects[document.selectedConnect];

    const ci = document.getElementById("connectIdentifierPulldown");
    selectedConnectData.destinationId = parseInt(ci.value);
    document.levelData.writeDoorConnect(document.levelNumber, document.selectedConnect, selectedConnectData);
    redrawConnectsPanel();
}


function connectSetOriginXY() {

    if (document.mapSelection.isEmpty()) {
        return;
    }
    const upperLeft = document.mapSelection.getUpperLeftCorner();

    const connects = document.levelData.getDoorConnects(document.levelNumber);
    const selectedConnectData = connects[document.selectedConnect];

    selectedConnectData.x = upperLeft.x;
    selectedConnectData.y = (mapRows-1)-upperLeft.y;
    document.levelData.writeDoorConnect(document.levelNumber, document.selectedConnect, selectedConnectData);
    redrawConnectsPanel();
    redrawSpriteCanvas();
}


function connectSetDestinationXY() {

    if (document.mapSelection.isEmpty()) {
        return;
    }
    const upperLeft = document.mapSelection.getUpperLeftCorner();

    const connects = document.levelData.getDoorConnects(document.levelNumber);
    const selectedConnectData = connects[document.selectedConnect];

    selectedConnectData.destinationX = upperLeft.x;
    selectedConnectData.destinationY = (mapRows-1)-upperLeft.y;
    document.levelData.writeDoorConnect(document.levelNumber, document.selectedConnect, selectedConnectData);
    redrawConnectsPanel();
    redrawSpriteCanvas();
}


function connectFifthOffsetChanged() {
    const connects = document.levelData.getDoorConnects(document.levelNumber);
    const selectedConnectData = connects[document.selectedConnect];

    const ci = document.getElementById("connectFifthOffsetPulldown");
    selectedConnectData.destinationXFifthOffset = parseInt(ci.value);
    document.levelData.writeDoorConnect(document.levelNumber, document.selectedConnect, selectedConnectData);
    redrawConnectsPanel();
    redrawSpriteCanvas();
}


function drawLevel() {
    var levelIdsCanvas = document.getElementById("levelIdsCanvas");
    var levelIdsContext = levelIdsCanvas.getContext("2d");

    for (var i=0; i < mapColumns; i++) {
        for (var j=0; j < mapRows; j++) {
            const blockType = document.levelData.getTypeBlock(i, j, document.levelNumber);
            levelIdsContext.putImageData(document.editorTiles.tiles[blockType],tileWidth*i,(tileHeight*j)+16);
        }
    }

    var levelPicsCanvas = document.getElementById("levelPicsCanvas");
    var levelPicsContext = levelPicsCanvas.getContext("2d");

    for (var i=0; i < mapColumns; i++) {
        for (var j=0; j < mapRows; j++) {
            const blockPic = document.levelData.getPictureBlock(i, j, document.levelNumber);
            levelPicsContext.putImageData(document.pictureTiles.tiles[blockPic],tileWidth*i,(tileHeight*j)+16);
        }
    }
};


// Redraws the tile at the given x and y on both canvases - Ids and Pics - using the map data.
function redrawTileFromMap(x, y) {
    var tileId = document.levelData.getTypeBlock(x, y, document.levelNumber);
    drawTypeTile(x, y, tileId, false);
    var tilePic = document.levelData.getPictureBlock(x, y, document.levelNumber);
    drawPicTile(x, y, tilePic);
}


// Erase the tiles within the rectangle defined by first {x:int,y:int} and second {x:int,y:int}
function eraseInteractionRectangle(first, second) {
    const xa = Math.max(Math.min(first.x, second.x), 0);
    const xb = Math.min(Math.max(first.x, second.x), mapColumns);
    const ya = Math.max(Math.min(first.y, second.y), 0);
    const yb = Math.min(Math.max(first.y, second.y), mapRows);

    var c = document.getElementById("levelInteractionCanvas");
    var canvasContext = c.getContext("2d");
    canvasContext.clearRect(tileWidth*xa,(tileHeight*ya)+16, tileWidth*((xb-xa)+1), tileHeight*((yb-ya)+1));
}


// Draw selection indicators for any selected blocks within the rectangle
// defined by first {x:int,y:int} and second {x:int,y:int}
function drawSelectionIndicatorsWithinRectangle(first, second) {
    const xa = Math.max(Math.min(first.x, second.x), 0);
    const xb = Math.min(Math.max(first.x, second.x), mapColumns);
    const ya = Math.max(Math.min(first.y, second.y), 0);
    const yb = Math.min(Math.max(first.y, second.y), mapRows);

    for (var x=xa; x <= xb; x++) {
        for (var y=ya; y <= yb; y++) {
            if (document.mapSelection.isSelected(x, y)) {
                drawTypeTile(x, y, 65, true);
            }
        }
    }
}


// Draw selection indicators for the given array of coordinate pairs {x:int,y:int}
function drawSelectionIndicators(locations) {
    locations.forEach(function(item) {
        drawTypeTile(item.x, item.y, 65, true);
    });
}


// Draw a "pending selection" indicator around the rectangle
// defined by first {x:int,y:int} and second {x:int,y:int}
function drawPendingSelectionRectangle(first, second) {
    const xa = Math.max(Math.min(first.x, second.x), 0);
    const xb = Math.min(Math.max(first.x, second.x), mapColumns);
    const ya = Math.max(Math.min(first.y, second.y), 0);
    const yb = Math.min(Math.max(first.y, second.y), mapRows);

    if (xa == xb) {
        // Special case: Can't draw a "pending selection" indicator that's one block in size
        if (ya == yb) {
            return;
        }
        drawTypeTile(xa, ya, 69, true);
        drawTypeTile(xa, yb, 101, true);
        for (var y=ya+1; y < yb; y++) {
            drawTypeTile(xa, y, 85, true);
        }
        return;
    }

    if (ya == yb) {
        drawTypeTile(xa, ya, 70, true);
        drawTypeTile(xb, ya, 72, true);
        for (var x=xa+1; x < xb; x++) {
            drawTypeTile(x, ya, 71, true);
        }
        return;
    }

    // Four unique corner tiles of a selection area that is at least 2x2
    drawTypeTile(xa, ya, 66, true);
    drawTypeTile(xb, ya, 68, true);
    drawTypeTile(xa, yb, 98, true);
    drawTypeTile(xb, yb, 100, true);
    // Any straight pieces connecting the corners (may be none)
    for (var x=xa+1; x < xb; x++) {
        drawTypeTile(x, ya, 67, true);
        drawTypeTile(x, yb, 99, true);
    }
    for (var y=ya+1; y < yb; y++) {
        drawTypeTile(xa, y, 82, true);
        drawTypeTile(xb, y, 84, true);
    }

    for (var x=xa+1; x < xb; x++) {
        for (var y=ya+1; y < yb; y++) {
            drawTypeTile(x, y, 83, true);
        }
    }
}


function eraseInteractionTile(x, y) {
    var c = document.getElementById("levelInteractionCanvas");
    var canvasContext = c.getContext("2d");
    canvasContext.clearRect(tileWidth*x,(tileHeight*y)+16, tileWidth, tileHeight);
}


// Draw the tile with the given Id at the given x and y on the levelIds canvas.
// If onInteractionLayer is true, draw the tile on the levelInteractionCanvas canvas instead.
function drawTypeTile(x, y, tileId, onInteractionLayer) {
    var canvasToDrawOn;
    if (onInteractionLayer) {
        canvasToDrawOn = document.getElementById("levelInteractionCanvas");
    } else {
        canvasToDrawOn = document.getElementById("levelIdsCanvas");
    }
    var canvasContext = canvasToDrawOn.getContext("2d");
    canvasContext.putImageData(document.editorTiles.tiles[tileId],tileWidth*x,(tileHeight*y)+16);
}


function drawPicTile(x, y, tileId) {
    var levelPicsCanvas = document.getElementById("levelPicsCanvas");
    var levelPicsContext = levelPicsCanvas.getContext("2d");
    levelPicsContext.putImageData(document.pictureTiles.tiles[tileId],tileWidth*x,(tileHeight*y)+16);
}


function changeMapPicsLayerOpacity() {
    var levelPicsOpacity = document.getElementById("levelPicsOpacity");
    var levelIdsCanvas = document.getElementById("levelIdsCanvas");
    levelIdsCanvas.style.opacity = levelPicsOpacity.value / 100;
};


function setMapPicsLayerOpacitySlider(value) {
    var levelPicsOpacity = document.getElementById("levelPicsOpacity");
    levelPicsOpacity.value = value;
    changeMapPicsLayerOpacity();
};


function levelMapFocused(event) {
    document.levelMapHasFocus = true;
    console.log("levelMapFocused");
}


function levelMapBlurred(event) {
    document.levelMapHasFocus = false;
    console.log("levelMapBlurred");
}


// Reads content from a LevelChanges and writes it to the map with the associated levelNumber.
// Note that this function does not care which level is visible in the editor.
function applyMapChanges(changes) {
    changes.blockTypeChanges.changes.forEach(function(item, index, array) {
        document.levelData.setTypeBlock(item.x, item.y, changes.levelNumber, item.value);
    });
    changes.blockPicChanges.changes.forEach(function(item, index, array) {
        document.levelData.setPicBlock(item.x, item.y, changes.levelNumber, item.value);
    });
}


// This assumes that change.levelNumber matches document.levelNumber
// otherwise the result on the screen would be nonsense.
function drawMapChanges(changes) {
    changes.blockTypeChanges.changes.forEach(function(item, index, array) {
        drawTypeTile(item.x, item.y, item.value, false);
    });
    changes.blockPicChanges.changes.forEach(function(item, index, array) {
        drawPicTile(item.x, item.y, item.value);
    });
}


function onLevelMapMouseDown(mouseEvent) {
    var c = document.getElementById("levelInteractionCanvas");
    const currentBlock = mousey.mouseEventToBlockLocation(c, mouseEvent, 16.0, 255, 11, 40/34);

    var b = document.getElementById("bodyId");
    b.addEventListener("mouseup", onLevelMapTriggeredMouseUp, {once: true });

    console.log("levelMap mousedown", currentBlock);

    document.blockLastMouseDown = currentBlock;

    document.optionKeyOnMouseDown = mouseEvent.altKey;
    document.commandKeyOnMouseDown = mouseEvent.metaKey;
    document.shiftKeyOnMouseDown = mouseEvent.shiftKey;

    if (!document.optionKeyOnMouseDown &&
        document.commandKeyOnMouseDown &&
        !document.shiftKeyOnMouseDown
    ) {
        console.log("New click-write history.");
        const h = new LevelUndoHistoryEntry(document.levelNumber);
        if ((currentBlock.y >= 0) && (currentBlock.y >= 0)) {
            const oldBlockType = document.levelData.getTypeBlock(currentBlock.x, currentBlock.y, document.levelNumber);
            const oldBlockPic = document.levelData.getPictureBlock(currentBlock.x, currentBlock.y, document.levelNumber);
            const oldTypeChange = {x: currentBlock.x, y: currentBlock.y, value: oldBlockType};
            const oldPicChange = {x: currentBlock.x, y: currentBlock.y, value: oldBlockPic};
            h.oldChanges.add([oldTypeChange], [oldPicChange]);
            const newTypeChange = {x: currentBlock.x, y: currentBlock.y, value: document.blockTypeSelection};
            const newPicChange = {x: currentBlock.x, y: currentBlock.y, value: document.blockPictureSelection};
            h.newChanges.add([newTypeChange], [newPicChange]);
            applyMapChanges(h.newChanges);
            drawMapChanges(h.newChanges);
        }
        document.pendingLevelChanges = h;
    }
}


function onLevelMapMouseOver(mouseEvent) {
    var c = document.getElementById("levelInteractionCanvas");
    const currentBlock = mousey.mouseEventToBlockLocation(c, mouseEvent, 16.0, 255, 11, 40/34);
    document.levelMapContainsMouse = true;
    if ((currentBlock.x == document.blockUnderPointer.x) && (currentBlock.y == document.blockUnderPointer.y)) {
        return;
    }

    // If the mouse is currently down
    if (document.blockLastMouseDown != null) {

        // Mouse down, command key down
        if (document.commandKeyOnMouseDown) {

            // Situation where the user has command-clicked in some other tile
            // and dragged the mouse into this one.
            // Action: Continue painting the currently selected block into this map location,
            // and move the reticle under the new mouse location.
            if (!document.optionKeyOnMouseDown &&
                !document.shiftKeyOnMouseDown &&
                (currentBlock.x >= 0) &&
                (currentBlock.y >= 0)
            ) {
                console.log("Add drag write to pending history.");
                if (document.pendingLevelChanges == null) {
                    console.log("Error: Pending changes not allocated?");
                    return;
                }
                if ((currentBlock.y >= 0) && (currentBlock.y >= 0)) {
                    const h = document.pendingLevelChanges;
                    // Basic container for this change, so we don't have to re-apply the whole pending set
                    const oldBlockType = document.levelData.getTypeBlock(currentBlock.x, currentBlock.y, document.levelNumber);
                    const oldBlockPic = document.levelData.getPictureBlock(currentBlock.x, currentBlock.y, document.levelNumber);
                    const oldBlockTypeChange = {x: currentBlock.x, y: currentBlock.y, value: oldBlockType};
                    const oldBlockPicChange = {x: currentBlock.x, y: currentBlock.y, value: oldBlockPic};
                    h.oldChanges.add([oldBlockTypeChange], [oldBlockPicChange]);
                    const newBlockTypeChange = {x: currentBlock.x, y: currentBlock.y, value: document.blockTypeSelection};
                    const newBlockPicChange = {x: currentBlock.x, y: currentBlock.y, value: document.blockPictureSelection};
                    h.newChanges.add([newBlockTypeChange], [newBlockPicChange]);
                    const c = new LevelChanges(document.levelNumber);
                    c.add([newBlockTypeChange], [newBlockPicChange]);
                    applyMapChanges(c);
                    drawMapChanges(c);
                }

                eraseInteractionTile(document.blockUnderPointer.x, document.blockUnderPointer.y);
                // If the tile the reticle was over previously was also selected, re-draw the selection
                // indicator after erasing the reticle.
                if (document.mapSelection.isSelected(document.blockUnderPointer.x, document.blockUnderPointer.y)) {
                    drawTypeTile(document.blockUnderPointer.x, document.blockUnderPointer.y, 65, true);
                }
                document.blockUnderPointer = currentBlock;
                drawTypeTile(currentBlock.x, currentBlock.y, 64, true);
            }
        } else {

            // Situation where the user has clicked in some other tile
            // and dragged the mouse into this one, with no modifier keys except possibly shift.
            // Action: Show a "new selection" rectangle between the other tile and this one.
            if (!document.optionKeyOnMouseDown &&
                !document.commandKeyOnMouseDown &&
                (currentBlock.x >= 0) &&
                (currentBlock.y >= 0)
            ) {
                // Remove evidence of old selection indicator and restore any selection visible below it
                eraseInteractionRectangle(document.blockLastMouseDown, document.blockUnderPointer);
                drawSelectionIndicatorsWithinRectangle(document.blockLastMouseDown, document.blockUnderPointer);
                document.blockUnderPointer = currentBlock;
                drawPendingSelectionRectangle(document.blockLastMouseDown, currentBlock);
                return;
            }
        }
    } else {

        // Situation where the user has NOT previously clicked down in some other tile,
        // but has moved the mouse into this one.
        // Action: Move the reticle here.
        if ((currentBlock.x >= 0) &&
            (currentBlock.y >= 0)
        ) {
            eraseInteractionTile(document.blockUnderPointer.x, document.blockUnderPointer.y);
            // If the tile the reticle was over previously was also selected, re-draw the selection
            // indicator after erasing the reticle.
            if (document.mapSelection.isSelected(document.blockUnderPointer.x, document.blockUnderPointer.y)) {
                drawTypeTile(document.blockUnderPointer.x, document.blockUnderPointer.y, 65, true);
            }
            document.blockUnderPointer = currentBlock;
            drawTypeTile(currentBlock.x, currentBlock.y, 64, true);
            return;
        }
    }
}


function onLevelMapTriggeredMouseUp(mouseEvent) {
    console.log("levelMap-triggered mouseup", document.blockUnderPointer);
    const lastMouseDown = document.blockLastMouseDown;
    document.blockLastMouseDown = null;

    if ((lastMouseDown == null) || (document.blockUnderPointer == null)) {
        console.log("Inadequate coordinates.");
        return;
    }

    // Command key
    if (document.commandKeyOnMouseDown) {
        // Apply accumulated changes from a command-click draw (and drag)
        if (!document.optionKeyOnMouseDown &&
            !document.shiftKeyOnMouseDown
        ) {
            console.log("Confirm drag writes history.");
            if (document.pendingLevelChanges == null) {
                console.log("Error: No pending level changes allocated.");
            }
            if (document.pendingLevelChanges.isEmpty()) {
                console.log("Pending level changes are empty; discarding.");
            } else {
                document.levelHistory.addEvent(document.pendingLevelChanges);
            }
            document.pendingLevelChanges = null;
        }

    // Option key
    } else if (document.optionKeyOnMouseDown) {
        // Eyedropper the current hovered block into the selections
        if (!document.commandKeyOnMouseDown &&
            !document.shiftKeyOnMouseDown &&
            document.levelMapContainsMouse &&
            (lastMouseDown.x == document.blockUnderPointer.x) &&
            (lastMouseDown.y == document.blockUnderPointer.y) &&
            (lastMouseDown.x >= 0) &&
            (lastMouseDown.y >= 0)
        ) {
            console.log("Eyedropper last clicked location.");
            const blockType = document.levelData.getTypeBlock(lastMouseDown.x, lastMouseDown.y, document.levelNumber);
            const blockPic = document.levelData.getPictureBlock(lastMouseDown.x, lastMouseDown.y, document.levelNumber);
            selectTypeBlock(blockType);
            selectPictureBlock(blockPic);
        }

    // Neither command key nor option key
    } else {

        // Situation where the user has clicked with no modifier keys except possibly shift,
        // and the reticle is not in the gutter.
        // Action: Accept current region between mouse down and mouse up as a new selection.
        // If shift was down, add to the current selection, otherwise replace.
        if ((lastMouseDown != null) &&
            (document.blockUnderPointer.x >= 0) &&
            (document.blockUnderPointer.y >= 0)
        ) {
            console.log("Selecting rectangle.");
            if (!document.shiftKeyOnMouseDown) {
                // If we're not adding to the selection, clear the whole interaction layer
                // and reset the existing selection before remaking it.
                eraseInteractionRectangle({x: 0, y: 0}, {x: mapColumns-1, y: mapRows-1});
                document.mapSelection.clear();
            }
            document.mapSelection.selectRectangle(lastMouseDown, document.blockUnderPointer);
            // Remove evidence of pending selection indicator and restore any selection visible below it.
            // we don't need to worry about drawing or redrawing the region outside this area,
            // since it will either be deselected and erased already, or unchanged.
            drawSelectionIndicatorsWithinRectangle(lastMouseDown, document.blockUnderPointer);
            // The reticle was erased by the previous steps, so we need to redraw it.
            drawTypeTile(document.blockUnderPointer.x, document.blockUnderPointer.y, 64, true);
        }
    }

    document.optionKeyOnMouseDown = false;
    document.commandKeyOnMouseDown = false;
    document.shiftKeyOnMouseDown = false;
}


function onLevelMapMouseOut(event) {
    document.levelMapContainsMouse = false;
    console.log("levelMap mouseout");
}


function onLevelMapCut(event) {
    if (!document.levelMapHasFocus) { return; }
    console.log("levelMap cut");
    if (document.mapSelection.isEmpty()) {
        console.log("Cannot cut an empty selection.");
        return;
    }

    const changesToCut = buildLevelChangesBasedOnCurrentSelection();

    const newClipboard = new MapClipboardContents(mapColumns, mapRows);
    newClipboard.fromLevelChanges(changesToCut);
    newClipboard.sendToClipboard(event);

    // Assemble a set of new changes based on the current selection,
    // one change per block, changing it to the currently selected type/pic.
    const newChanges = new LevelChanges(document.levelNumber);
    const allLocations = document.mapSelection.all();
    const newBlockTypeChanges = allLocations.map(function(m) {
        return {x: m.x, y: m.y, value: document.blockTypeSelection}
    });
    const newBlockPicChanges = allLocations.map(function(m) {
        return {x: m.x, y: m.y, value: document.blockPictureSelection}
    });
    newChanges.add(newBlockTypeChanges, newBlockPicChanges);

    const h = new LevelUndoHistoryEntry(document.levelNumber);
    h.oldChanges = changesToCut;
    h.newChanges = newChanges;

    applyMapChanges(newChanges);
    drawMapChanges(newChanges);

    document.levelHistory.addEvent(h);
}


function onLevelMapCopy(event) {
    if (!document.levelMapHasFocus) { return; }
    console.log("levelMap copy");
    if (document.mapSelection.isEmpty()) {
        console.log("Cannot copy an empty selection.");
        return;
    }

    const changesToCopy = buildLevelChangesBasedOnCurrentSelection();

    const newClipboard = new MapClipboardContents(mapColumns, mapRows);
    newClipboard.fromLevelChanges(changesToCopy);
    newClipboard.sendToClipboard(event);
}


function onLevelMapPaste(event) {
    if (!document.levelMapHasFocus) { return; }
    console.log("levelMap paste");
    const newClipboard = new MapClipboardContents(mapColumns, mapRows);
    newClipboard.fromClipboardPasteEvent(event);
    if (newClipboard.isEmpty()) {
        console.log("Paste event contained no usable selection.");
        return;
    }

    // Get the upper left corner of the current selection _before_ clearing it!
    const upperLeft = document.mapSelection.getUpperLeftCorner();
    document.mapSelection.clear();

    // Assumes that type and pic selections are identical - may be a bad assumption
    const newSelection = newClipboard.blockTypeChanges.asSelection();
    const offsetSelection = newSelection.map(function(item) {
        return { x: item.x + upperLeft.x, y: item.y + upperLeft.y }
    });

    // Assumes that type and pic selections are identical - may be a bad assumption
    document.mapSelection.select(offsetSelection);

    // Erase any current selection
    eraseInteractionRectangle({x: 0, y: 0}, {x: mapColumns-1, y: mapRows-1});
    // Draw the new selection based on the pasted data (could be irregular in shape)
    const pasteSelection = document.mapSelection.all();
    drawSelectionIndicators(pasteSelection);

    // Now that we've changed the current selection to the pasted area,
    // use the selection to read out the data we're going to be pasting over.
    // We use this to make an undo history entry.
    const previousContents = buildLevelChangesBasedOnCurrentSelection();
    const newContents = newClipboard.asLevelChanges(document.levelNumber, upperLeft);

    const h = new LevelUndoHistoryEntry(document.levelNumber);
    h.oldChanges = previousContents;
    h.newChanges = newContents;

    applyMapChanges(newContents);
    drawMapChanges(newContents);

    document.levelHistory.addEvent(h);
}


function onLevelMapKeyDown(keyEvent) {
    if (!document.levelMapHasFocus) { return; }
    // Not supporting any keyboard operations while a click is pending.
    if (document.blockLastMouseDown != null) { return; }
    console.log("levelMap keydown");

    const optionDown = keyEvent.altKey;
    const commandDown = keyEvent.metaKey;
    const controlDown = keyEvent.ctrlKey;

    // Z with ctrl or meta = undo or redo
    if ((keyEvent.keyCode == 90) && (controlDown || commandDown)) {
        keyEvent.preventDefault()
        var changes = null;
        if (keyEvent.shiftKey) {
            console.log("redo");
            changes = document.levelHistory.redo();
        } else {
            console.log("undo");
            changes = document.levelHistory.undo();
        }
        if (changes != null) {
            const newSelection = changes.asSelection();

            document.mapSelection.clear();
            eraseInteractionRectangle({x: 0, y: 0}, {x: mapColumns-1, y: mapRows-1});

            document.mapSelection.select(newSelection);
            drawSelectionIndicators(newSelection);

            applyMapChanges(changes);
            if (document.levelNumber != changes.levelNumber) {
                // This will redraw all of both map layers,
                // so there's no need to drawMapChanges in this case.
                forceLevelSelect(changes.levelNumber);
            } else {
                drawMapChanges(changes);
            }
        }
        return;
    }

    // Delete or backspace key = fill current selected are with current type/pic selections
    if ((keyEvent.keyCode == 46) || (keyEvent.keyCode == 8)) {
        console.log("Delete/backspace.");
        if (document.mapSelection.isEmpty()) {
            console.log("Cannot clear an empty selection.");
            return;
        }

        const changesToClear = buildLevelChangesBasedOnCurrentSelection();

        // Assemble a set of new changes based on the current selection,
        // one change per block, changing it to the currently selected type/pic.
        const newChanges = new LevelChanges(document.levelNumber);
        const allLocations = document.mapSelection.all();
        const newBlockTypeChanges = allLocations.map(function(m) {
            return {x: m.x, y: m.y, value: document.blockTypeSelection}
        });
        const newBlockPicChanges = allLocations.map(function(m) {
            return {x: m.x, y: m.y, value: document.blockPictureSelection}
        });
        newChanges.add(newBlockTypeChanges, newBlockPicChanges);

        const h = new LevelUndoHistoryEntry(document.levelNumber);
        h.oldChanges = changesToClear;
        h.newChanges = newChanges;

        applyMapChanges(newChanges);
        drawMapChanges(newChanges);

        document.levelHistory.addEvent(h);

        keyEvent.preventDefault()
        return;
    }

    // Space bar with option = read tile under reticle into type/pic selection    
    if ((keyEvent.keyCode == 32) && optionDown) {
        console.log("Eyedropper reticle location.");

        const m = document.blockUnderPointer;
        const blockType = document.levelData.getTypeBlock(m.x, m.y, document.levelNumber);
        const blockPic = document.levelData.getPictureBlock(m.x, m.y, document.levelNumber);
        selectTypeBlock(blockType);
        selectPictureBlock(blockPic);

        keyEvent.preventDefault()
        return;
    }

    // Space bar without option = write selected tile under reticle
    if ((keyEvent.keyCode == 32) && (!optionDown)) {
        console.log("Spacebar write.");

        const m = document.blockUnderPointer;
        // Can't do this operation over a gutter tile.
        if ((m.y < 0) || (m.y < 0)) { return; }

        // New undo history entry with one changed tile
        const h = new LevelUndoHistoryEntry(document.levelNumber);
        const oldBlockType = document.levelData.getTypeBlock(m.x, m.y, document.levelNumber);
        const oldBlockPic = document.levelData.getPictureBlock(m.x, m.y, document.levelNumber);
        const oldTypeChange = {x: m.x, y: m.y, value: oldBlockType};
        const oldPicChange = {x: m.x, y: m.y, value: oldBlockPic};
        h.oldChanges.add([oldTypeChange], [oldPicChange]);
        const newTypeChange = {x: m.x, y: m.y, value: document.blockTypeSelection};
        const newPicChange = {x: m.x, y: m.y, value: document.blockPictureSelection};
        h.newChanges.add([newTypeChange], [newPicChange]);
        applyMapChanges(h.newChanges);
        drawMapChanges(h.newChanges);
        document.levelHistory.addEvent(h);

        keyEvent.preventDefault()
        return;
    }

    // Escape key = clear selection
    if (keyEvent.keyCode == 27) {
        keyEvent.preventDefault()
        document.mapSelection.clear();
        eraseInteractionRectangle({x: 0, y: 0}, {x: mapColumns-1, y: mapRows-1});
        drawTypeTile(document.blockUnderPointer.x, document.blockUnderPointer.y, 64, true);
        return;
    }

    // Arrow keys = move reticle
    if ((keyEvent.keyCode == 38) || (keyEvent.keyCode == 40) ||
        (keyEvent.keyCode == 37) || (keyEvent.keyCode == 39))   {

        var newLocation = {
            x: document.blockUnderPointer.x,
            y: document.blockUnderPointer.y
        };
        if (keyEvent.keyCode == 38) {   // Up arrow
            newLocation.y = Math.max(document.blockUnderPointer.y-1, 0);
        } else if (keyEvent.keyCode == 40) {    // Down arrow
            newLocation.y = Math.min(document.blockUnderPointer.y+1, mapRows-1);
        } else if (keyEvent.keyCode == 37) {    // Left arrow
            newLocation.x = Math.max(document.blockUnderPointer.x-1, 0);
        } else if (keyEvent.keyCode == 39) {    // Right arrow
            newLocation.x = Math.min(document.blockUnderPointer.x+1, mapColumns-1);
        }

        eraseInteractionTile(document.blockUnderPointer.x, document.blockUnderPointer.y);
        // If the tile the reticle was over previously was also selected, re-draw the selection
        // indicator after erasing the reticle.
        if (document.mapSelection.isSelected(document.blockUnderPointer.x, document.blockUnderPointer.y)) {
            drawTypeTile(document.blockUnderPointer.x, document.blockUnderPointer.y, 65, true);
        }
        document.blockUnderPointer = newLocation;
        drawTypeTile(newLocation.x, newLocation.y, 64, true);

        keyEvent.preventDefault()

        return;
    }

//    } else {
//        let supportedKey =
//            match keyEvent.keyCode with
//            | 13.0 -> Some VesselKey.Enter    // Enter key
//            | 65.0 -> Some VesselKey.KeyA
//            | _ -> None
//    }
}


function buildLevelChangesBasedOnCurrentSelection() {
    const allLocations = document.mapSelection.all();
    const changes = new LevelChanges(document.levelNumber, true);
	allLocations.forEach(function(m) {
        const blockType = document.levelData.getTypeBlock(m.x, m.y, document.levelNumber);
        const blockPic = document.levelData.getPictureBlock(m.x, m.y, document.levelNumber);
        changes.add([{x: m.x, y: m.y, value: blockType}], [{x: m.x, y: m.y, value: blockPic}]);
    });
    return changes;
}


function populateTypeBlockSelector() {
    var c = document.getElementById("typeBlockSelectionCanvas");
    var canvasContext = c.getContext("2d");

    for (var x=0; x < 4; x++) {
        for (var y=0; y < 16; y++) {
            var tileId = (y * 4) + x;
            canvasContext.putImageData(document.editorTiles.tiles[tileId],tileWidth*x,tileHeight*y);
        }
    }
};


function populatePictureBlockSelector() {
    var c = document.getElementById("pictureBlockSelectionCanvas");
    var canvasContext = c.getContext("2d");

    for (var x=0; x < 16; x++) {
        for (var y=0; y < 16; y++) {
            var tileId = (y * 16) + x;
            canvasContext.putImageData(document.pictureTiles.tiles[tileId],tileWidth*x,tileHeight*y);
        }
    }
};


function clickOnTypeBlockSelector(event) {
    var c = document.getElementById("typeBlockSelectionInteractionCanvas");
    const coordinates = mousey.mouseEventToBlockLocation(c, event, 0.0, 3, 15, 40/34);
    const type = Math.max(0, coordinates.x) + (Math.max(0, coordinates.y)*4);
    selectTypeBlock(type);
};


function clickOnPictureBlockSelector(event) {
    var c = document.getElementById("pictureBlockSelectionInteractionCanvas");
    const coordinates = mousey.mouseEventToBlockLocation(c, event, 0.0, 15, 15, 40/34);
    const type = Math.max(0, coordinates.x) + (Math.max(0, coordinates.y)*16);
    selectPictureBlock(type);
    selectTypeBlock(firstBlocksetTypeEquivalents[type]);
};


function selectTypeBlock(newSelection) {
    var c = document.getElementById("typeBlockSelectionInteractionCanvas");
    var canvasContext = c.getContext("2d");

    const xPrevious = document.blockTypeSelection % 4;
    const yPrevious = Math.floor(document.blockTypeSelection / 4);
    canvasContext.clearRect(tileWidth*xPrevious, tileHeight*yPrevious, tileWidth, tileHeight);

    const x = newSelection % 4;
    const y = Math.floor(newSelection / 4);
    canvasContext.putImageData(document.editorTiles.tiles[65], tileWidth*x, tileHeight*y);

    document.blockTypeSelection = newSelection;
}


function selectPictureBlock(newSelection) {
    var c = document.getElementById("pictureBlockSelectionInteractionCanvas");
    var canvasContext = c.getContext("2d");

    const xPrevious = document.blockPictureSelection % 16;
    const yPrevious = Math.floor(document.blockPictureSelection / 16);
    canvasContext.clearRect(tileWidth*xPrevious, tileHeight*yPrevious, tileWidth, tileHeight);

    const x = newSelection % 16;
    const y = Math.floor(newSelection / 16);
    canvasContext.putImageData(document.editorTiles.tiles[65], tileWidth*x, tileHeight*y);

    document.blockPictureSelection = newSelection;
}


function pressedSaveButton(event) {
    const linkSource = document.levelData.asHrefData();

    const downloadLink = document.getElementById("levelDownloadLink");
    downloadLink.href = linkSource;
    downloadLink.target = '_self';
    downloadLink.download = "world_" + worldNumber + "-level_1_to_4.bin";
}


</script>

</head>

<body id="bodyId" onLoad="startEditor();">

    <div class="topBar">
        <h3>SMT Map Editor</h3>
        <div>
            <select class="worldPulldown" id="worldPulldown" onchange="worldPulldownChanged();">
                <option value="1">World 1</option>
                <option value="2">World 2</option>
                <option value="3">World 3</option>
                <option value="4">World 4</option>
                <option value="5">World 5</option>
                <option value="6">World 6</option>
                <option value="7">World 7</option>
            </select>
        </div>

        <div>
            <select class="levelPulldown" id="levelPulldown" onchange="levelPulldownChanged();">
                <option value="0">Level 1</option>
                <option value="1">Level 2</option>
                <option value="2">Level 3</option>
                <option value="3">Level 4</option>
            </select>
        </div>

        <div>
            <div class="panelTabs">
                <div id="mapEditingPanelTab" onclick="selectMapPanel();">Map</div>
                <div id="connectsPanelTab" onclick="selectConnectsPanel();">Connects</div>
            </div>
        </div>

        <div>
            <span onclick="setMapPicsLayerOpacitySlider(0);">Pic</span>
            <input type="range" class="levelPicsOpacitySlider" id="levelPicsOpacity"
                min="0" max="100" value="20" oninput="changeMapPicsLayerOpacity();" />
            <span onclick="setMapPicsLayerOpacitySlider(100);">Type</span>
        </div>
    </div>

    <canvas style="display:none;" id="tempCanvas" width=640 height=384></canvas>
    <canvas style="display:none;" id="tempBlockSetCanvas" width=40 height=6144></canvas>
    <canvas style="display:none;" id="tempBlockCanvas" width=40 height=32></canvas>

    <div id="levelContainer" class="levelContainer"
            tabindex="0"
            onfocus="levelMapFocused(event);"
            onblur="levelMapBlurred(event);"
            onkeydown="onLevelMapKeyDown(event);">
        <canvas id="levelIdsCanvas" class="levelIdsCanvas" width=10240 height=400></canvas>
        <canvas id="levelSpriteCanvas" class="levelSpriteCanvas" width=10240 height=400></canvas>
        <canvas id="levelInteractionCanvas" class="levelInteractionCanvas" width=10240 height=400
            onmousedown="onLevelMapMouseDown(event);"
            onmouseout="onLevelMapMouseOut(event);"
            onmousemove="onLevelMapMouseOver(event);"></canvas>
        <canvas id="levelPicsCanvas" class="levelPicsCanvas" width=10240 height=400></canvas>
        <div class="mapColumnIndexes" id="mapColumnIndexes"></div>
    </div>

    <div id="mapEditingPanel">
        <div class="bottomPanel">

            <div id="pictureBlockSelectionContainer" class="pictureBlockSelectionContainer">
                <canvas id="pictureBlockSelectionInteractionCanvas" class="pictureBlockSelectionInteractionCanvas" width=640 height=512 onclick="clickOnPictureBlockSelector(event);"></canvas>
                <canvas id="pictureBlockSelectionCanvas" class="pictureBlockSelectionCanvas" width=640 height=512></canvas>
            </div>

            <div id="typeBlockSelectionContainer" class="typeBlockSelectionContainer">
                <canvas id="typeBlockSelectionInteractionCanvas" class="typeBlockSelectionInteractionCanvas" width=160 height=512 onclick="clickOnTypeBlockSelector(event);"></canvas>
                <canvas id="typeBlockSelectionCanvas" class="typeBlockSelectionCanvas" width=160 height=512></canvas>
            </div>
        </div>

        <h3>How To Use</h3>

        <p>
            To switch between the block pictures and block types layers, drag the slider, or click directly on "Pic" or "Type".
        </p>
        <p>
            Click in the block pictures gallery (below the map) to select a block picture to draw with.
            The standard block type that goes with that picture will be auto-selected in the type gallery to the right.
        </p>
        <p>
            Command-click on a block in the map to place the selected block.  The picture and the type layer will both be affected.
            Drag while the mouse is down to draw more blocks.
        </p>
        <p>
            Use Command-Z (or Control-Z) to undo changes, and Command-Shift-Z (Control-Shift-Z) to redo them.
        </p>
        <p>
            Click to make a selection.  A rectangle will appear.  Drag to make the selection larger.
            Shift-click or drag to add to the current selection.  With a selection you can:
        </p>
        <p>
            <ul>
                <li>Press "Delete" to fill the selection with the currently selected block.</li>
                <li>Perform "Cut", "Copy", and "Paste" operations with the usual keyboard shortcuts.</li>
                <li>Hold down Command and press an arrow key to move the selection <i>and its contents</i> around on the map.</li>
                <li>Press "Escape" to de-select.</li>
            </ul>
        </p>
        <p>
            You can also use the arrow keys to move the hover indicator.
            Press Space to write the currently selected block, and Option-Space to read the hovered block into the selection.
        </p>
        <p>
            Option-click on a block in the map to select that type in the blockset.
        </p>

    </div>

    <div id="connectsPanel">
        <div class="bottomPanel">
            <div id="connectsEditingForm" class="connectsEditingForm">
                <div class="connectsEditingSubForm">
                    <div class="oneItem">Origin:</div>
                    <div class="oneItem"><input type="button" value="Set Origin" onclick="connectSetOriginXY(event);" /></div>
                </div>
                <div class="connectsEditingSubForm">
                    <div class="oneItem">Destination:</div>
                    <div class="connectsEditingSubForm">
                        <div class="connectsEditingRow">
                            <div>
                                <select class="destinationTypePulldown" id="destinationTypePulldown"
                                    onchange="connectDestinationTypeChanged(event);">
                                    <option value="0">In This Level</option>
                                    <option value="1">Other Level</option>
                                    <option value="2">A Level Set</option>
                                    <option value="3">A World</option>
                                </select>
                            </div>
                            <div>Identifier: 
                                <select class="connectIdentifierPulldown" id="connectIdentifierPulldown"
                                    onchange="connectIdentifierChanged(event);">
                                    <option value="0">1 / a</option>
                                    <option value="1">2 / b</option>
                                    <option value="2">3 / c</option>
                                    <option value="3">4 / d</option>
                                    <option value="4">5 / e</option>
                                    <option value="5">6 / f</option>
                                    <option value="6">7 / g</option>
                                    <option value="7">8 / h</option>
                                    <option value="8">9 / i</option>
                                    <option value="9">10 / j</option>
                                    <option value="10">11 / k</option>
                                    <option value="11">12 / l</option>
                                    <option value="12">13 / m</option>
                                    <option value="13">14 / n</option>
                                    <option value="14">15 / o</option>
                                    <option value="15">16 / p</option>
                                </select>
                            </div>
                            <div><input type="button" value="Set X Of Screen Left Edge" /></div>
                        </div>
                        <div class="connectsEditingRow">
                            <div><input type="button" value="Set X/Y" onclick="connectSetDestinationXY(event);" /></div>
                            <div>Extra data: <input type="text" id="connectExtraData" size="4" /></div>
                            <div>Block Offset: 
                                <select class="connectFifthOffsetPulldown" id="connectFifthOffsetPulldown"
                                    onchange="connectFifthOffsetChanged(event);">
                                    <option value="0">None</option>
                                    <option value="1">1/5 Right</option>
                                    <option value="2">2/5 Right</option>
                                    <option value="3">3/5 Right</option>
                                    <option value="4">4/5 Right</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="connectsView" class="connectsView">
                <table class="connectsTable">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>x</th>
                            <th>y</th>
                            <th>type</th>
                            <th>id</th>
                            <th>dx</th>
                            <th>dy</th>
                            <th>sx</th>
                            <th>fifth</th>
                            <th>extra</th>
                        </tr>
                    </thead>
                    <tbody id="connectsFirstTableBody" >
                    </tbody>
                </table>
                <table class="connectsTable">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>x</th>
                            <th>y</th>
                            <th>type</th>
                            <th>id</th>
                            <th>dx</th>
                            <th>dy</th>
                            <th>sx</th>
                            <th>fifth</th>
                            <th>extra</th>
                        </tr>
                    </thead>
                    <tbody id="connectsSecondTableBody" >
                    </tbody>
                </table>
            </div>
        </div>

        <h3>How To Use</h3>

        <p>
            You have 16 numbered slots for connecting doors to their destinations.  Click one to edit it.
        </p>
        <p>
            The "x y" hex coordinates point to a door block.
            Door blocks always come in pairs, and these coordinates must always point to the lower, or leftmost block in the pair.
            For reference, an image of Guido labeled "IN" is placed on the map in the area Guido must stand in order to use the door.
            For example, if the door block is of the "pipe down" type, the "IN" Guido will be above it, standing on the right edge.
            If the coordinates don't point to a door block, the connection won't work.
            If the door block isn't next to a second (making a pair), it won't work.
        </p>
        <p>
            To set the origin for a door connection, select a slot, then select a door block on the map, then click "Set Origin".
            To set the destination, select an empty block on the map and click "Set X/Y" in the Destination section.
        </p>
        <p>
            Clicking on the "x y" values in the table will scroll the map so that entrance is visible.
            Clicking on the "dx dy sx" values will make that destination visible.
        </p>
        <p>
            For more detailed information, go ask somebody!
        </p>

    </div>

    <h4>
        How to save your work:
    </h4>
    <p>
        Press this
        <input type="button" value="save" onclick="pressedSaveButton(event);" />
        button, then <a id="levelDownloadLink" href="">click here</a>
        to get the currently selected level set as file.
    </p>
    <p>
        Note that Safari has an extremely pernicious caching system, and you may have to click Develop -> Empty Caches to get your file changes to appear.
    <p>
</body>
</html>